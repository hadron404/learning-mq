利用RabbitMQ的一些特性实现的特殊功能案例

基于 TTL 和 DLX 实现延时任务

准备
* DLX：死信交换机。Queue A 死信投递的交换机，通过交换机的路由 投递到目标队列
* Queue A：由生产者投递TTL消息的队列
* Queue B：死信交换机投放消息的队列，由消费者监听的队列

该方案存在的问题

消息消费的时序问题，因为是基于队列实现的，而队列的特性是先进先出，那么先进队列的消息会先消费，如果进入队列的消息的初始 TTL 是一致的，那么先进队列的消息一定是 先过期，消息便会按队列进入顺序进行消费。 如果 队列的每条消息的 TTL， 是不一致的，这种不一致特指 先入队列的消息的 TTL 可能大于 后入队列消息的 TTL ，那么后入队列的消息一定会被先入队的消息阻塞，即使后入队的消息的 已经提前过期。一定会等待队列中的队首消息被消费之后，才会进行消费。这就是所谓的时序问题。

这种方案一般仅适用于 消息的过期时间是一致的场景


基于 delay-message 插件实现
[rabbitmq-delayed-message-exchange](https://github.com/rabbitmq/rabbitmq-delayed-message-exchange)

针对第一种方案的缺点，通过 delay-message 插件实现延时任务，并解决时序问题。
